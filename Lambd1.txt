import botocore
import boto3
import datetime
import os
from botocore.exceptions import ClientError
# Inputs from Environment Variables

# Global Variables
# sns_arn = os.environ["sns_arn"]

# Environment Variable: RotationPeriod
# The number of days after which a key should be rotated
# rotationPeriod = int(os.environ['RotationPeriod'])
rotationPeriod = 90

# Environment Variable: InactivePeriod
# The number of days after which to inactivate keys that had been rotated
# Note: This must be greater than RotationPeriod
# oldKeyInactivationPeriod = int(os.environ['InactivePeriod'])
oldKeyInactivationPeriod = 100

# Environment Variable: RetentionPeriod
# The number of days after which to delete keys that have been rotated and inactivated
# Note: This must be greater than InactivePeriod
# oldKeyDeletionPeriod = int(os.environ['RetentionPeriod'])
oldKeyDeletionPeriod = 110

# Pre-calculate the rotation and retention cutoff dates
rotationDate = (datetime.datetime.now() -
                datetime.timedelta(days=rotationPeriod)).date()
inactivationDate = (datetime.datetime.now() -
                    datetime.timedelta(days=oldKeyInactivationPeriod)).date()
deletionDate = (datetime.datetime.now() -
                datetime.timedelta(days=oldKeyDeletionPeriod)).date()

# Format for lines in credentials.txt
akidLineFormat = 'aws_access_key_id = {}'
secretLineFormat = 'aws_secret_access_key = {}'

# Format for name of ASM secrets
secretNameFormat = 'User_{}_AccessKey'

# Format for ARN of ASM secrets
secretArnFormat = 'arn:aws:secretsmanager:{region_name}:{account_id}:secret:{secret_name}'

# Format for Secret Manager Resource Policy
secretPolicyFormat = """
{{
    "Version": "2012-10-17",
    "Statement": [
        {{
            "Effect": "Allow",
            "Principal": {{
                "AWS": "arn:aws:iam::{account_id}:user/{user_name}"
            }},
            "Action": [
                "secretsmanager:GetSecretValue",
                "secretsmanager:DescribeSecret",
                "secretsmanager:ListSecretVersionIds",
                "secretsmanager:ListSecrets"
            ],
            "Resource": "*"
        }}
    ]
}}
"""

iamPolicyFormat = """{{
    "Version": "2012-10-17",
    "Statement": [
        {{
            "Sid": "RetrieveSecretValue",
            "Effect": "Allow",
            "Action": [
                "secretsmanager:GetSecretValue",
                "secretsmanager:DescribeSecret",
                "secretsmanager:ListSecretVersionIds"
            ],
            "Resource": "{secret_arn}"
        }},
        {{
            "Sid": "ListSecret",
            "Effect": "Allow",
            "Action": "secretsmanager:ListSecrets",
            "Resource": "*"
        }}
    ]
}}
"""

# IAM Client
iam = boto3.client('iam')

# Secrets Manager Client
sm = boto3.client('secretsmanager')
my_session = boto3.session.Session()
my_region = my_session.region_name

# SNS Client
# sns_client = boto3.client('sns')

sts_client = boto3.client('sts')


def lambda_handler(event, context):

    users = iam.list_users()
    response = {}

    force_rotate_user_name = None
    # if "ForceRotate" in event:
    #     force_rotate_user_name = event['ForceRotate']

    for user in users['Users']:
        user_name = user['UserName']
        if user_name == force_rotate_user_name:
            process_user(user, response, True)
        else:
            process_user(user, response, False)

    # Build a response for debugging - doesn't change actual work done, just gives output for testing in Lambda console
    # response = build_response(results)
    response['RotationDate'] = rotationDate.__str__()
    return response


# def get_message(user_name, context):
#     """Format SNS Message Function"""
#     secret_name = secretNameFormat.format(user_name)
#     message = f"A new AWS IAM Access Key pair was created. Please access your secret named {secret_name} to retrieve the new Access Keys and update your applications accordingly.\n\n"
#     message += "UserName: " + str(user_name) + "\n"
#     message += "Account: " + get_account_id() + "\n"
#     message += "\n\n"
#     message += "This notification was generated by the AWS Lambda Function. " + \
#         context.invoked_function_arn
#     return message
#
#
# def send_message(message):
#     """Send SNS Publish Function."""
#     try:
#         response = sns_client.publish(
#             TopicArn=sns_arn,
#             Message=message,
#             Subject="New AWS IAM Access Key Pair Created."
#         )
#     except ClientError as error:
#         print(error)


def get_account_id():
    """
    Gets the current account ID.

    :return The current account Id of the Lambda function.
    """
    try:
        account_id = sts_client.get_caller_identity().get("Account")
    except ClientError as error:
        print(error)

    return account_id


def process_user(user, response, force=False):
    """Rotate access keys for a user.

    Inactive keys will be deleted
    Users with no active access keys will not be processed
    Users with an access key older than the rotation date will have a new key created and stored in ASM, deleting the oldest key if necessary.
    Users with an active access key older than the inactivation date, and an active access key newer than the rotation date will have the oldest key inactivated.
    Users with an inactive access key older than the deletion period, and an active access key newer than the rotation date will have the oldest key deleted
    On a single run of this lambda, a key will only move from active to inactive or inactive to deleted.
    """

    user_name = user['UserName']
    response[user_name] = {}
    lak = iam.list_access_keys(UserName=user_name)

    num_keys = 0

    # Active Keys
    active_keys = []

    # Inactive Keys
    inactive_keys = []

    # Oldest Key
    oldest_key = None

    # Classify all access keys for the current user
    for akm in lak['AccessKeyMetadata']:
        num_keys += 1
        if oldest_key is None or oldest_key['CreateDate'] > akm['CreateDate']:
            oldest_key = akm
        if akm['Status'] == 'Active':
            active_keys.append(akm)
        else:
            inactive_keys.append(akm)

    num_active = len(active_keys)
    num_inactive = len(inactive_keys)

    if force:
        # Rotation of user is forced for testing
        if num_active == 2:
            # Two active keys. Delete oldest and rotate
            key_to_delete = oldest_key['AccessKeyId']
            iam.delete_access_key(UserName=user_name,
                                  AccessKeyId=key_to_delete)
            response[user_name]["Deleted Old Key"] = key_to_delete
            create_access_key(user, response)
            response[user_name]["Action"] = "Key rotated."
        else:
            create_access_key(user, response)
            response[user_name]["Action"] = "Key rotated."
    elif num_active == 2:
        classification_1 = classify_date(active_keys[0])
        classification_2 = classify_date(active_keys[1])

        # Two Active Keys
        if classification_1 == "New" or classification_2 == "New":
            # At least one key is new. Handle oldest one according to inactivation/deletion dates
            handle_oldest_key(user_name, response, oldest_key)
        else:
            # Both keys older than rotation date. Delete oldest and create new
            key_to_delete = oldest_key['AccessKeyId']
            iam.delete_access_key(UserName=user_name,
                                  AccessKeyId=key_to_delete)
            response[user_name]["Deleted Old Key"] = key_to_delete
            create_access_key(user, response)
            response[user_name]["Action"] = "Key rotated."
    elif num_active == 1 and num_inactive == 1:
        # One active and one inactive. Handle inactive key according to inactivation/deletion dates
        handle_oldest_key(user_name, response, inactive_keys[0])
    elif num_active == 1 and num_inactive == 0:
        # Single key that is active. Rotate if necessary.
        classification = classify_date(active_keys[0])
        if classification == "New":
            response[user_name]["Action"] = "No key rotation required."
        else:
            create_access_key(user, response)
            response[user_name]["Action"] = "Key rotated."
    elif num_active == 0 and num_inactive > 0:
        # If no active keys, delete all inactive keys
        response[user_name]["Deleted Inactive Keys"] = []
        for key_to_delete in inactive_keys:
            iam.delete_access_key(UserName=user_name,
                                  AccessKeyId=key_to_delete)
            response[user_name]["Deleted Inactive Keys"].append(key_to_delete)


def classify_date(akm):
    creation_date = akm['CreateDate'].date()
    if creation_date > rotationDate:
        return "New"
    if creation_date > inactivationDate:
        return "Rotate"
    if creation_date > deletionDate:
        return "Inactivate"
    return "Delete"


def handle_oldest_key(user_name, response, oldest_key):
    classification = classify_date(oldest_key)

    if classification == "Inactivate":
        key_to_inactivate = oldest_key['AccessKeyId']
        iam.update_access_key(UserName=user_name,
                              AccessKeyId=key_to_inactivate, Status='Inactive')
        response[user_name]["Inactivated Old Key"] = key_to_inactivate
    elif classification == "Delete":
        key_to_delete = oldest_key['AccessKeyId']
        iam.delete_access_key(UserName=user_name, AccessKeyId=key_to_delete)
        response[user_name]["Deleted Old Key"] = key_to_delete


def format_secret_arn(secret_name):
    account_id = get_account_id()

    return secretArnFormat.format(account_id=account_id, secret_name=secret_name, region_name=my_region)


def format_secret_policy(user):
    account_id = get_account_id()
    user_name = user['UserName']

    return secretPolicyFormat.format(account_id=account_id, user_name=user_name)


def format_iam_policy(secret_arn):
    account_id = get_account_id()

    return iamPolicyFormat.format(account_id=account_id, secret_arn=secret_arn)


def create_resource_policy(user, secret_name, secret_arn):
    resource_policy_document = format_secret_policy(user)
    sm.put_resource_policy(
        SecretId=secret_name, ResourcePolicy=resource_policy_document, BlockPublicPolicy=True)


def create_iam_policy_if_not_exist(user, secret_arn):
    user_name = user['UserName']
    create_policy = False
    policy_name = 'SecretsAccessPolicy'
    try:
        iam.get_user_policy(UserName=user_name, PolicyName=policy_name)
    except botocore.exceptions.ClientError as e:
        # TODO - IAM uses IAM.Client.exceptions.NoSuchEntityException
        #        Find out if it inherits from ClientError. If it does, this code is  probably ok,
        #        but may need to change ResourceNotFoundException to NoSucheEntityException
        if e.response['Error']['Code'] == 'NoSuchEntity':
            create_policy = True
        else:
            raise e  # Go Bonk

    if create_policy:
        policy_document = format_iam_policy(secret_arn)
        iam.put_user_policy(
            UserName=user_name, PolicyName=policy_name, PolicyDocument=policy_document)


def create_access_key(user, response):
    user_name = user['UserName']
    secret_name = secretNameFormat.format(user_name)
    secret_arn = format_secret_arn(secret_name)

    # Create new access key
    new_access_key = iam.create_access_key(UserName=user_name)
    response[user_name]["Created Access Key"] = new_access_key['AccessKey']['AccessKeyId']
    response[user_name]["ASM Secret Name"] = secret_name

    akid_line = akidLineFormat.format(
        new_access_key['AccessKey']['AccessKeyId'])
    secret_line = secretLineFormat.format(
        new_access_key['AccessKey']['SecretAccessKey'])
    cred_file_body = '{}\n{}'.format(akid_line, secret_line)

    # Create new secret, or store in existing
    create_secret = False
    try:
        # See if the secret we need already exists
        sm.describe_secret(SecretId=secret_name)
    except botocore.exceptions.ClientError as e:
        if e.response['Error']['Code'] == 'ResourceNotFoundException':
            create_secret = True
        else:
            raise e  # Go Bonk

    if create_secret:
        sm.create_secret(
            Name=secret_name, Description='Auto-created secret', SecretString=cred_file_body)
    else:
        sm.put_secret_value(SecretId=secret_name, SecretString=cred_file_body)

    create_resource_policy(user, secret_name, secret_arn)
    create_iam_policy_if_not_exist(user, secret_arn)


lambda_handler(None, None)
